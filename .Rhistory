# Suppress warning messages
suppressWarnings({
library(readr)
library(vip)
library(naniar)
library(tidymodels)
library(ISLR)
library(ISLR2)
library(tidyverse)
library(glmnet)
library(modeldata)
library(ggthemes)
library(janitor)
library(kableExtra)
library(yardstick)
library(kknn)
library(corrplot)
library(themis)
library(dplyr)
library(ggplot2)
library(scales)
library(rpart.plot)
library(discrim)
library(klaR)
library(plotly)
library(ranger)
library(xgboost)
tidymodels_prefer()
})
# Suppress warning messages
suppressWarnings({
library(readr)
library(vip)
library(naniar)
library(tidymodels)
library(ISLR)
library(ISLR2)
library(tidyverse)
library(glmnet)
library(modeldata)
library(ggthemes)
library(janitor)
library(kableExtra)
library(yardstick)
library(kknn)
library(corrplot)
library(themis)
library(dplyr)
library(ggplot2)
library(scales)
library(rpart.plot)
library(discrim)
library(klaR)
library(plotly)
library(ranger)
library(xgboost)
tidymodels_prefer()
})
db <- read.csv("~/Downloads/diabetes.csv")
db
db <- read.csv("~/Downloads/diabetes.csv")
db
vis_miss(db)
db %>%
ggplot(aes(x = Outcome)) + geom_bar() +
theme_bw()
db %>%
group_by(Outcome) %>%
summarise(prop = n()/(dim(db)[1]))
# Plot the distribution of customer ages using a histogram
ggplot(db, aes(x = Age)) +
geom_histogram(binwidth = 5, color = "black", fill = "blue") +
labs(title = "Distribution of Patient Ages", x = "Age", y = "Age")
# Plot the distribution of customer balances using a density plot
ggplot(db, aes(x = BMI)) +
geom_density(fill = "red", alpha = 0.5) +
labs(title = "Distribution of BMI", x = "Balance", y = "frequency")
# Plot the distribution of customer credit scores using a box plot
ggplot(db, aes(y = Insulin)) +
geom_boxplot(color = "black", fill = "green", alpha = 0.5) +
labs(title = "Distribution of Insulin", y = "Insulin")
distribution <- function(db, column) {
min_col <- min(db[[column]])
max_col <- max(db[[column]])
# Convert the column to numeric
db[[column]] <- as.numeric(db[[column]])
# Split the data by "Outcome" group
diabetes_data <- db[db$Outcome == 1, column]
no_diabetes_data <- db[db$Outcome == 0, column]
# Set up the plot with two side-by-side histograms
par(mfrow = c(1, 2))
# Histogram for "diabetes == 1"
hist(diabetes_data,
main = paste0("Diabetes Present ", column, " "),
xlab = column,
ylab = "Frequency",
col = "red",
breaks = seq(min_col - 1, max_col + 1, by = 1),
xlim = c(min_col, max_col),
ylim = c(0, max(hist(diabetes_data, breaks = seq(min_col - 1, max_col + 1, by = 1), plot = FALSE)$counts)),
density = 10,
angle = 45,
border = "white")
# Histogram for "no diabetes == 0"
hist(no_diabetes_data,
main = paste0("Diabetes Absent ", column, " "),
xlab = column,
ylab = "Frequency",
col = "blue",
breaks = seq(min_col - 1, max_col + 1, by = 1),
xlim = c(min_col, max_col),
ylim = c(0, max(hist(no_diabetes_data, breaks = seq(min_col - 1, max_col + 1, by = 1), plot = FALSE)$counts)),
density = 10,
angle = 45,
border = "white")
# Reset the layout
par(mfrow = c(1, 1))
}
# Example usage
distribution(db, "Age")
#bank_df$Exited_num <- as.numeric(bank_df$Exited) # Convert Exited to numeric variable
diabetes_numeric <- db %>%
select_if(is.numeric) # Select only numeric columns
cor_matrix <- cor(diabetes_numeric) # Compute correlation matrix
corrplot(cor_matrix, type = "lower", diag = FALSE) # Plot correlation matrix
# covert survived and pclass into factors
diabetes_numeric$Outcome <- as.factor(diabetes_numeric$Outcome)
# sort the data frame by survived, so the yes will be on top
db_sort <- db%>% arrange(desc(Outcome))
head(db_sort)
set.seed(3435)
db_split <- initial_split(db, prop = 0.80,
strata = "Outcome")
db_train <- training(db_split)
db_test <- testing(db_split)
db_fold <- vfold_cv(db_train,v=4)
db_train$Outcome <- factor(db_train$Outcome)
db_recipe_demo <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors()) %>%
step_upsample(Outcome, over_ratio = 0.5, skip = FALSE)
prep(db_recipe_demo) %>% bake(new_data = db_train) %>%
group_by(Outcome) %>%
summarise(count = n())
db_recipe <- recipe(Outcome ~ ., data = db_train ) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors()) %>%
step_upsample(Outcome, over_ratio = 1)
library(recipes)
library(themis)
library(tidymodels)
# Convert "Outcome" to factor in your original dataset
db_train$Outcome <- factor(db_train$Outcome)
# knn
knn_model <- nearest_neighbor(neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("classification")
# Use the updated recipe with "Outcome" as a factor
db_recipe <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors()) %>%
step_upsample(Outcome, over_ratio = 0.5, skip = FALSE)
db_knn_wflow <- workflow() %>%
add_model(knn_model) %>%
add_recipe(db_recipe)
neighbors_grid <- grid_regular(neighbors(range = c(1, 10)), levels = 10)
# knn
db_tune_knn <- tune_grid(
object = db_knn_wflow,
resamples = db_fold,
grid = neighbors_grid
)
best_knn_db <- select_best(db_tune_knn,
metric = "roc_auc",
neighbors
)
library(recipes)
library(tidymodels)
# Convert "Outcome" to factor in your original dataset
db_train$Outcome <- factor(db_train$Outcome)
# Recipe without step_upsample
db_recipe <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors())
# Apply the recipe to the training data
db_train_preprocessed <- bake(db_recipe, new_data = db_train)
db_train$Outcome <- factor(db_train$Outcome)
db_recipe_demo <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors()) %>%
step_upsample(Outcome, over_ratio = 0.5, skip = FALSE)
prep(db_recipe_demo) %>% bake(new_data = db_train) %>%
group_by(Outcome) %>%
summarise(count = n())
library(recipes)
library(tidymodels)
# Convert "Outcome" to factor in your original dataset
db_train$Outcome <- factor(db_train$Outcome)
# Recipe without step_upsample
db_recipe <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors())
# Prepare the recipe
db_recipe_prep <- prep(db_recipe)
# Apply the recipe to the training data
db_train_preprocessed <- bake(db_recipe_prep, new_data = db_train)
# Upsample the minority class
db_train_upsampled <- themis::make_upsample_stratified(
db_train_preprocessed,
"Outcome",
over_ratio = 0.5
)
library(recipes)
library(tidymodels)
# Convert "Outcome" to factor in your original dataset
db_train$Outcome <- factor(db_train$Outcome)
# Recipe without step_upsample
db_recipe <- recipe(Outcome ~ ., data = db_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_predictors())
# Prepare the recipe
db_recipe_prep <- prep(db_recipe)
# Apply the recipe to the training data
db_train_preprocessed <- bake(db_recipe_prep, new_data = db_train)
# Upsample the minority class using rsample
db_train_upsampled <- rsample::ovunify(Outcome ~ ., data = db_train_preprocessed, method = "over", p = 0.5)$data
install.packages("ranger")
